#!/usr/bin/env python3
##############################################################################
# (c) Crown copyright 2023 Met Office. All rights reserved.
# The file LICENCE, distributed with this code, contains details of the terms
# under which the code may be used.
##############################################################################
from argparse import ArgumentParser
from pathlib import Path
import logging
from logging import getLogger
from sys import exit as sys_exit, stderr
from typing import List

from modules.occupy_fortran import entry

if __name__ == '__main__':
    TEXT = "Searches Fortran source for global variables."
    parser = ArgumentParser(description=TEXT, add_help=False)
    parser.add_argument('-help', '-h', '--help', action='help',
                        help="Print this message and exit.")
    parser.add_argument('-version', action='version',
                        version='%(prog)s 0.1.0',
                        help="Print version information and exit.")
    parser.add_argument('-debug', action='store_true',
                        help="Log more information.")
    subparsers = parser.add_subparsers(dest='operation', help="Operations")

    file_operation = subparsers.add_parser(
        "file", add_help=False,
        help="Filename specifies a file object."
    )
    file_operation.add_argument('-help', '-h', '--help', action='help',
                                help="Print this message and exit.")
    file_operation.add_argument('-cleanlist',
                                help="Generate a list of passing files")

    list_operation = subparsers.add_parser(
        "list", add_help=False,
        help="Filename specifies a list file."
    )
    list_operation.add_argument('-help', '-h', '--help', action='help',
                                help="Print this message and exit.")

    parser.add_argument('-directory', type=Path, default=Path(),
                        help="Scan relative to this directory.")
    parser.add_argument('filename', type=Path, default=Path())
    arguments = parser.parse_args()

    logger = getLogger('occupyfortran')
    logger.addHandler(logging.StreamHandler())
    if arguments.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    file_objects: List[Path] = []
    if arguments.operation == 'list':
        for line in arguments.filename.read_text().splitlines():
            if line.strip() and not line.strip().startswith('#'):
                file_objects.append(arguments.directory / Path(line))
    elif arguments.operation == 'file':
        file_objects.append(arguments.directory / arguments.filename)
    else:
        raise Exception(f"Unrecognised operation: {arguments.operation}")

    try:
        dirty_list, clean_list, not_considered = entry(file_objects)
    except FileNotFoundError as ex:
        print(f"Could not open file \"{ex.filename}\", has it been renamed?",
              file=stderr)
        sys_exit(2)

    globals_found = 0  # pylint: disable=invalid-name
    for report in dirty_list:
        for problem in report.dirt:
            globals_found += 1
            MESSAGE = ' : '.join([str(report.filename),
                                  str(problem.line_number),
                                  problem.fortran_type,
                                  problem.variable_name])
            getLogger('occupyfortran').error(MESSAGE)

    if 'cleanlist' in arguments:
        clean_list_filename = Path() / 'cleanlist.txt'
        if clean_list_filename.exists():
            clean_list_filename.unlink()
        if len(clean_list) > 0:
            clean_list.sort()
            with clean_list_filename.open('w', encoding='utf8') as fhandle:
                print("""
# Files should only ever be added or renamed in this file, never removed.
""".strip(), file=fhandle)
                print("#", file=fhandle)
                for clean_filename in clean_list:
                    print(str(clean_filename), file=fhandle)

    # pylint: disable=invalid-name
    total_scanned = len(dirty_list) + len(clean_list) + len(not_considered)
    message = f"Found {globals_found} global variables " \
              f"in {len(dirty_list)} files."
    getLogger('occupyfortran').info(message)
    message = f"Meanwhile no problems found in {len(clean_list)} files."
    getLogger('occupyfortran').info(message)
    message = f"Overall {total_scanned} scanned."
    getLogger('occupyfortran').info(message)

    if len(dirty_list) > 0:
        sys_exit(1)
    else:
        sys_exit(0)
