!------------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!------------------------------------------------------------------------------
!> @brief  Test the linear_state_trajectory subroutine
!!
module linear_state_trajectory_test

  use constants_mod,                 only : i_def, l_def, str_def, r_def
  use field_collection_mod,          only : field_collection_type
  use field_mod,                     only : field_type, field_proxy_type
  use fs_continuity_mod,             only : W3, Wtheta
  use function_space_collection_mod, only : function_space_collection_type, &
                                            function_space_collection
  use halo_routing_collection_mod,   only : halo_routing_collection_type, &
                                            halo_routing_collection
  use local_mesh_mod,                only : local_mesh_type
  use mesh_mod,                      only : mesh_type
  use mesh_collection_mod,           only : mesh_collection_type, &
                                            mesh_collection
  use linear_state_trajectory_mod,   only : linear_state_trajectory_type
  use jedi_lfric_field_meta_mod,     only : jedi_lfric_field_meta_type
  use jedi_lfric_datetime_mod,       only : jedi_datetime_type
  use jedi_lfric_duration_mod,       only : jedi_duration_type

  use pFUnit_Mod

  implicit none

  private
  public :: test_linear_state_trajectory

  @TestCase
  type, extends(TestCase), public :: linear_state_trajectory_test_type
    private
    type(local_mesh_type)         :: unit_test_local_mesh
    type(mesh_type),      pointer :: mesh => null()
  contains
    procedure setUp
    procedure tearDown
    procedure get_local_mesh_ptr
    procedure test_linear_state_trajectory
  end type linear_state_trajectory_test_type

  integer(i_def), parameter    :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use mesh_mod, only : mesh_type, PLANE_BI_PERIODIC

    implicit none

    class(linear_state_trajectory_test_type), intent(inout) :: this
    type(local_mesh_type), pointer :: unit_test_local_mesh_ptr => null()
    type(mesh_type) :: unit_test_mesh
    integer(i_def)  :: mesh_id

    ! Create top level mesh collection
    mesh_collection = mesh_collection_type()
    ! Create top level function space collection
    function_space_collection = function_space_collection_type()
    ! Create top level halo_routing collection
    halo_routing_collection = halo_routing_collection_type()

    call this%unit_test_local_mesh%initialise()
    unit_test_local_mesh_ptr => this%get_local_mesh_ptr()

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    unit_test_mesh = mesh_type( PLANE_BI_PERIODIC, unit_test_local_mesh_ptr )
    mesh_id        = mesh_collection%add_new_mesh( unit_test_mesh )
    this%mesh     => mesh_collection%get_mesh( mesh_id )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(linear_state_trajectory_test_type), intent(inout) :: this

    call function_space_collection%clear()
    call mesh_collection%clear()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function get_local_mesh_ptr( this ) result(unit_test_local_mesh_ptr)

    implicit none

    class(linear_state_trajectory_test_type), intent(inout), target :: this
    type(local_mesh_type), pointer :: unit_test_local_mesh_ptr

    unit_test_local_mesh_ptr => this%unit_test_local_mesh

  end function get_local_mesh_ptr

  !> Test for the linear_state_trajectory_type
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_linear_state_trajectory( this )

    implicit none

    class(linear_state_trajectory_test_type), intent(inout) :: this

    ! Local
    type( jedi_datetime_type )             :: start_datetime
    type( jedi_datetime_type )             :: current_datetime
    type( jedi_datetime_type )             :: test_datetime
    type( jedi_duration_type )             :: forecast_length
    type( jedi_duration_type )             :: time_step
    type( jedi_lfric_field_meta_type )     :: field_meta_data
    type( linear_state_trajectory_type )   :: linear_state_trajectory
    type( field_collection_type ), pointer :: linear_state_collection
    type( field_type ), pointer            :: field_ptr
    type( field_proxy_type )               :: field_proxy
    integer( kind=i_def ), parameter       :: nvars = 3_i_def
    integer( kind=i_def ), parameter       :: ntimes = 3_i_def
    integer( kind=i_def )                  :: ivar
    integer( kind=i_def )                  :: itime
    character( len=str_def )               :: variable_names(nvars)
    integer( kind=i_def )                  :: variable_function_spaces(nvars)
    logical( kind=l_def )                  :: variable_is_2d(nvars)
    real( kind=r_def )                     :: variable_initial_value(nvars, ntimes)
    real( kind=r_def )                     :: expected_value(nvars)

    ! Define the field information
    variable_names = (/"field1", "field2", "field3"/)
    variable_function_spaces = (/W3 , Wtheta, W3/)
    variable_is_2d = (/.false., .false., .false./)

    ! Define the time step and forecast length duration and start datetime
    call time_step%init('P0DT0H30M0S')
    call forecast_length%init('P0DT1H0M0S')
    call start_datetime%init('2023-05-04T09:00:00Z')

    ! Define initial values for the fields
    variable_initial_value(:,1) = (/0.0, -1.0, 2.0/)
    variable_initial_value(:,2) = (/3.0, 10.0, 5.0/)
    variable_initial_value(:,3) = (/0.5, -6.0, 9.0/)

    ! Setup the meta data
    call field_meta_data%initialise( variable_names,           &
                                     variable_function_spaces, &
                                     variable_is_2d )
    ! Create a linear state object
    call linear_state_trajectory%initialise( forecast_length, time_step, &
                                             field_meta_data, this%mesh )

    ! Create the linear states and initialise the values using variable_initial_value
    current_datetime = start_datetime
    do itime=1,ntimes
      ! Create next linear state
      call linear_state_trajectory%create_next_linear_state( current_datetime, linear_state_collection )
      ! Setup the fields with some known values to populate the linear_state_collection
      do ivar=1,nvars
        call linear_state_collection%get_field(variable_names(ivar), field_ptr)
        field_proxy = field_ptr%get_proxy()
        field_proxy%data = variable_initial_value(ivar,itime)
      enddo
      ! Move time on by one time step
      current_datetime = current_datetime + time_step
    end do

    ! Retrieve the linear state collections and compare with expected values

    ! 1. Start datetime
    call test_datetime%init( '2023-05-04T09:00:00Z' )
    expected_value = (/0.0, -1.0, 2.0/)
    call linear_state_trajectory%get_linear_state( test_datetime, linear_state_collection )
    do ivar=1,nvars
      call linear_state_collection%get_field(variable_names(ivar), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(ivar))
    enddo

    ! 2. Start plus 0.5 time step
    call test_datetime%init( '2023-05-04T09:15:00Z' )
    expected_value = (/1.5, 4.5, 3.5/)
    call linear_state_trajectory%get_linear_state( test_datetime, linear_state_collection )
    do ivar=1,nvars
      call linear_state_collection%get_field(variable_names(ivar), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(ivar))
    enddo

    ! 3. Start plus 1 time step
    call test_datetime%init( '2023-05-04T09:30:00Z' )
    expected_value = (/3.0, 10.0, 5.0/)
    call linear_state_trajectory%get_linear_state( test_datetime, linear_state_collection )
    do ivar=1,nvars
      call linear_state_collection%get_field(variable_names(ivar), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(ivar))
    enddo

    ! 4. Start plus 1.5 time step
    call test_datetime%init( '2023-05-04T09:45:00Z' )
    expected_value = (/1.75, 2.0, 7.0/)

    call linear_state_trajectory%get_linear_state( test_datetime, linear_state_collection )
    do ivar=1,nvars
      call linear_state_collection%get_field(variable_names(ivar), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(ivar))
    enddo

    ! 5. Last datetime
    call test_datetime%init( '2023-05-04T10:00:00Z' )
    expected_value = (/0.5, -6.0, 9.0/)
    call linear_state_trajectory%get_linear_state( test_datetime, linear_state_collection )
    do ivar=1,nvars
      call linear_state_collection%get_field(variable_names(ivar), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(ivar))
    enddo

  end subroutine test_linear_state_trajectory

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

end module linear_state_trajectory_test
