!------------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!------------------------------------------------------------------------------
!> @brief  Test the trajectory_copy_fields subroutine
!!
module trajectory_copy_fields_test

  use constants_mod,                 only : i_def, l_def, str_def, r_def
  use field_collection_mod,          only : field_collection_type
  use field_mod,                     only : field_type, field_proxy_type
  use integer_field_mod,             only : integer_field_type, &
                                            integer_field_proxy_type
  use fs_continuity_mod,             only : W3, Wtheta
  use function_space_collection_mod, only : function_space_collection_type, &
                                            function_space_collection
  use halo_routing_collection_mod,   only : halo_routing_collection_type, &
                                            halo_routing_collection
  use local_mesh_mod,                only : local_mesh_type
  use mesh_mod,                      only : mesh_type
  use mesh_collection_mod,           only : mesh_collection_type, &
                                            mesh_collection
  use extrusion_mod,                 only : TWOD
  use trajectory_copy_fields_mod, &
                                     only : trajectory_copy_fields

  use pFUnit_Mod

  implicit none

  private
  public :: test_trajectory_copy_fields_real, test_trajectory_copy_fields_int

  @TestCase
  type, extends(TestCase), public :: trajectory_copy_fields_test_type
    private
    type(local_mesh_type)         :: unit_test_local_mesh
    type(mesh_type),      pointer :: mesh => null(), twod_mesh => null()
  contains
    procedure setUp
    procedure tearDown
    procedure get_local_mesh_ptr
    procedure create_real_collection
    procedure create_integer_collection
    procedure test_trajectory_copy_fields_real
    procedure test_trajectory_copy_fields_int
  end type trajectory_copy_fields_test_type

  integer(i_def), parameter    :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use mesh_mod, only : mesh_type, PLANE_BI_PERIODIC, PLANE_TWOD_BI_PERIODIC

    implicit none

    class(trajectory_copy_fields_test_type), intent(inout) :: this
    type(local_mesh_type), pointer :: unit_test_local_mesh_ptr => null()
    type(mesh_type) :: unit_test_mesh, unit_test_mesh_2d
    integer(i_def)  :: mesh_id

    ! Create top level mesh collection
    mesh_collection = mesh_collection_type()
    ! Create top level function space collection
    function_space_collection = function_space_collection_type()
    ! Create top level halo_routing collection
    halo_routing_collection = halo_routing_collection_type()

    call this%unit_test_local_mesh%initialise()
    unit_test_local_mesh_ptr => this%get_local_mesh_ptr()

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    unit_test_mesh = mesh_type( PLANE_BI_PERIODIC, unit_test_local_mesh_ptr )
    mesh_id        = mesh_collection%add_new_mesh( unit_test_mesh )
    this%mesh     => mesh_collection%get_mesh( mesh_id )

    ! Create the 2D mesh
    unit_test_mesh_2d = mesh_type( PLANE_TWOD_BI_PERIODIC, unit_test_local_mesh_ptr )
    mesh_id           = mesh_collection%add_new_mesh( unit_test_mesh_2d )
    this%twod_mesh   => mesh_collection%get_mesh_variant( this%mesh, TWOD )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(trajectory_copy_fields_test_type), intent(inout) :: this

    call function_space_collection%clear()
    call mesh_collection%clear()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function get_local_mesh_ptr( this ) result(unit_test_local_mesh_ptr)

    implicit none

    class(trajectory_copy_fields_test_type), intent(inout), target :: this
    type(local_mesh_type), pointer :: unit_test_local_mesh_ptr

    unit_test_local_mesh_ptr => this%unit_test_local_mesh

  end function get_local_mesh_ptr

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine create_real_collection( this, field_collection,      &
                                     variable_names_in,           &
                                     variable_function_spaces_in, &
                                     variable_is_2d_in,           &
                                     variable_initial_value,      &
                                     field_collection_name )

    implicit none

    class(trajectory_copy_fields_test_type), intent(in) :: this
    type( field_collection_type ), intent(out) :: field_collection
    character( len=str_def ),       intent(in) :: variable_names_in(:)
    integer( kind=i_def ),          intent(in) :: variable_function_spaces_in(:)
    logical( kind=l_def ),          intent(in) :: variable_is_2d_in(:)
    real( kind=r_def ),             intent(in) :: variable_initial_value(:)
    character( len=* ),             intent(in) :: field_collection_name

    ! Local
    type(mesh_type), pointer        :: mesh
    type( field_type ), allocatable :: field
    type( field_proxy_type )        :: field_proxy
    integer                         :: i

    ! Setup the field_collection
    call field_collection%initialise( &
             name = trim(field_collection_name), table_len=100)

    ! Create and add the fields defined in the list of variable names
    do i=1,size(variable_function_spaces_in)
      if (variable_is_2d_in(i)) then
        mesh => this%twod_mesh
      else
        mesh => this%mesh
      end if

      allocate(field)

      call field%initialise( &
             vector_space = function_space_collection%get_fs                &
                    ( mesh, element_order, variable_function_spaces_in(i)), &
             name = variable_names_in(i) )

      field_proxy = field%get_proxy()
      field_proxy%data = variable_initial_value(i)

      call field_collection%add_field( field )

      deallocate( field )

    end do

  end subroutine create_real_collection

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine create_integer_collection( this,                        &
                                        field_collection,            &
                                        variable_names_in,           &
                                        variable_function_spaces_in, &
                                        variable_is_2d_in,           &
                                        variable_initial_value,      &
                                        field_collection_name )

    implicit none

    class(trajectory_copy_fields_test_type), intent(in) :: this
    type( field_collection_type ), intent(out) :: field_collection
    character( len=str_def ),       intent(in) :: variable_names_in(:)
    integer( kind=i_def ),          intent(in) :: variable_function_spaces_in(:)
    logical( kind=l_def ),          intent(in) :: variable_is_2d_in(:)
    integer( kind=i_def ),          intent(in) :: variable_initial_value(:)
    character( len=* ),             intent(in) :: field_collection_name

    ! Local
    type(mesh_type), pointer                :: mesh
    type( integer_field_type ), allocatable :: field
    type( integer_field_proxy_type )        :: field_proxy
    integer                                 :: i

    ! Setup the field_collection
    call field_collection%initialise( &
            name = trim(field_collection_name), table_len=100)

    ! Create and add the fields defined in the list of variable names
    do i=1,size(variable_function_spaces_in)
      if (variable_is_2d_in(i)) then
        mesh => this%twod_mesh
      else
        mesh => this%mesh
      end if

      allocate(field)

      call field%initialise( &
             vector_space = function_space_collection%get_fs                &
                    ( mesh, element_order, variable_function_spaces_in(i)), &
             name = variable_names_in(i) )

      field_proxy = field%get_proxy()
      field_proxy%data = variable_initial_value(i)

      call field_collection%add_field( field )

      deallocate( field )

    end do

  end subroutine create_integer_collection

  !> Test for the trajectory_copy_fields subroutine using
  !> real fields
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_trajectory_copy_fields_real( this )

    implicit none

    class(trajectory_copy_fields_test_type), intent(inout) :: this

    ! Local
    type( field_collection_type )    :: field_collection_in
    type( field_collection_type )    :: field_collection_out
    type(field_type), pointer        :: field_ptr
    type( field_proxy_type )         :: field_proxy
    integer( kind=i_def ), parameter :: nvars_in = 3_i_def
    character( len=str_def )         :: variable_names_in(nvars_in)
    integer( kind=i_def )            :: variable_function_spaces_in(nvars_in)
    logical( kind=l_def )            :: variable_is_2d_in(nvars_in)
    real( kind=r_def )               :: variable_initial_value_in(nvars_in)
    integer( kind=i_def ), parameter :: nvars_out = 4_i_def
    character( len=str_def )         :: variable_names_out(nvars_out)
    integer( kind=i_def )            :: variable_function_spaces_out(nvars_out)
    logical( kind=l_def )            :: variable_is_2d_out(nvars_out)
    real( kind=r_def )               :: variable_initial_value_out(nvars_out)
    real( kind=r_def )               :: expected_value(nvars_out)
    integer( kind=i_def )            :: i

    ! Define the field information
    variable_names_in = (/"rfield1", "rfield2", "rfield3"/)
    variable_function_spaces_in = (/W3 , Wtheta, W3/)
    variable_is_2d_in = (/.false., .false., .true./)
    variable_initial_value_in = (/1.0, 2.0, 3.0/)

    variable_names_out = (/"rfield1", "rfield2", "rfield3", "rfield4"/)
    variable_function_spaces_out = (/W3, Wtheta, W3, Wtheta/)
    variable_is_2d_out = (/.false., .false., .true., .true./)
    variable_initial_value_out = (/4.0, 5.0, 6.0, 7.0/)

    ! Create collections
    call this%create_real_collection(                             &
                  field_collection_in, variable_names_in,         &
                  variable_function_spaces_in, variable_is_2d_in, &
                  variable_initial_value_in, 'field_collection_in')
    call this%create_real_collection(                               &
                  field_collection_out, variable_names_out,         &
                  variable_function_spaces_out, variable_is_2d_out, &
                  variable_initial_value_out, 'field_collection_out')

    ! -- Compare with the initial condition
    expected_value = (/4.0, 5.0, 6.0, 7.0/)
    do i=1,nvars_out
      call field_collection_out%get_field(variable_names_out(i), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(i))
    enddo

    ! Do the copy
    call trajectory_copy_fields( field_collection_out, &
                                 field_collection_in )
    ! Check the copied values
    expected_value = (/1.0, 2.0, 3.0, 7.0/)
    do i=1,nvars_out
      call field_collection_out%get_field(variable_names_out(i), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(i))
    enddo

  end subroutine test_trajectory_copy_fields_real

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !> Test for the trajectory_copy_fields subroutine using
  !> integer fields
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_trajectory_copy_fields_int( this )

    implicit none

    class(trajectory_copy_fields_test_type), intent(inout) :: this

    ! Local
    type( field_collection_type )     :: field_collection_in
    type( field_collection_type )     :: field_collection_out
    type(integer_field_type), pointer :: field_ptr
    type( integer_field_proxy_type )  :: field_proxy
    integer( kind=i_def ), parameter  :: nvars_in = 3_i_def
    character( len=str_def )          :: variable_names_in(nvars_in)
    integer( kind=i_def )             :: variable_function_spaces_in(nvars_in)
    logical( kind=l_def )             :: variable_is_2d_in(nvars_in)
    integer( kind=i_def )             :: variable_initial_value_in(nvars_in)
    integer( kind=i_def ), parameter  :: nvars_out = 4_i_def
    character( len=str_def )          :: variable_names_out(nvars_out)
    integer( kind=i_def )             :: variable_function_spaces_out(nvars_out)
    logical( kind=l_def )             :: variable_is_2d_out(nvars_out)
    integer( kind=i_def )             :: variable_initial_value_out(nvars_out)
    integer( kind=i_def )             :: expected_value(nvars_out)
    integer( kind=i_def )             :: i

    ! Define the field information
    variable_names_in = (/"ifield1", "ifield2", "ifield3"/)
    variable_function_spaces_in = (/W3 , Wtheta, W3/)
    variable_is_2d_in = (/.false., .false., .true./)
    variable_initial_value_in = (/1, 2, 3/)

    variable_names_out = (/"ifield1", "ifield2", "ifield3", "ifield4"/)
    variable_function_spaces_out = (/W3, Wtheta, W3, Wtheta/)
    variable_is_2d_out = (/.false., .false., .true., .true./)
    variable_initial_value_out = (/4, 5, 6, 7/)

    ! Create collections
    call this%create_integer_collection(                            &
                    field_collection_in, variable_names_in,         &
                    variable_function_spaces_in, variable_is_2d_in, &
                    variable_initial_value_in, 'field_collection_in')
    call this%create_integer_collection(                              &
                    field_collection_out, variable_names_out,         &
                    variable_function_spaces_out, variable_is_2d_out, &
                    variable_initial_value_out, 'field_collection_out')

    ! Compare with the initial condition
    expected_value = (/4, 5, 6, 7/)
    do i=1,nvars_out
      call field_collection_out%get_field(variable_names_out(i), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(i))
    enddo

    ! Do the copy
    call trajectory_copy_fields( field_collection_out, &
                                 field_collection_in )
    ! Check the copied values
    expected_value = (/1, 2, 3, 7/)
    do i=1,nvars_out
      call field_collection_out%get_field(variable_names_out(i), field_ptr)
      field_proxy = field_ptr%get_proxy()
      @assertEqual(field_proxy%data(1), expected_value(i))
    enddo

  end subroutine test_trajectory_copy_fields_int

end module trajectory_copy_fields_test
